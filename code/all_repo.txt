import { failure, Result, success } from "../../utils/Error/ErrorMangament";
import Database from 'better-sqlite3';

export abstract class BaseRepository<T, TCreate extends object, TUpdate extends object, ID = number> {
  protected tableName: string;
  protected db: Database.Database;

  constructor(database: Database.Database, tableName: string) {
    this.db = database;
    this.tableName = tableName;
  }

  // -------------------
  // CREATE
  // -------------------

  create(data: TCreate): Result<T> {
    try {
      const keys = Object.keys(data).join(', ');
      const placeholders = Object.keys(data).map(() => '?').join(', ');
      const values = Object.values(data);

      const stmt = this.db.prepare(
        `INSERT INTO ${this.tableName} (${keys}) VALUES (${placeholders})`
      );

      const info = stmt.run(values);

      const createdRow = { ...(data as any), id: info.lastInsertRowid } as T;
      return success(createdRow);
    } catch (err) {
      return failure('DATABASE', `Error creating record in ${this.tableName}`, err);
    }
  }


  // -------------------
  // READ
  // -------------------

  findById(id: ID): Result<T> {
    try {
      const row = this.db.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(id);
      if (!row) return failure('NOT_FOUND', `${this.tableName} record not found`);
      return success(row as T);
    } catch (err) {
      return failure('DATABASE', `Error fetching ${this.tableName}`, err);
    }
  }

  // READ by arbitrary column
  findBy<K extends keyof T>(column: K, value: T[K]): Result<T[]> {
    try {
      const rows = this.db.prepare(`SELECT * FROM ${this.tableName} WHERE ${String(column)} = ?`).all(value);
      return success(rows as T[]);
    } catch (err) {
      return failure('DATABASE', `Error fetching ${this.tableName} by ${String(column)}`, err);
    }
  }

  findAll(): Result<T[]> {
    try {
      const rows = this.db.prepare(`SELECT * FROM ${this.tableName}`).all();
      return success(rows as T[]);
    } catch (err) {
      return failure('DATABASE', `Error fetching ${this.tableName}`, err);
    }
  }

  // -------------------
  // UPDATE
  // -------------------

  update(id: ID, data: TUpdate): Result<T> {
    try {
      const keys = Object.keys(data);
      if (keys.length === 0) return failure('INVALID_ARG', 'No fields to update');

      const setClause = keys.map(key => `${key} = ?`).join(', ');
      const values = Object.values(data);

      const stmt = this.db.prepare(
        `UPDATE ${this.tableName} SET ${setClause} WHERE id = ?`
      );

      const info = stmt.run(...values, id);

      if (info.changes === 0) return failure('NOT_FOUND', `${this.tableName} record not found`);

      return this.findById(id);
    } catch (err) {
      return failure('DATABASE', `Error updating record in ${this.tableName}`, err);
    }
  }

  // -------------------
  // DELETE
  // -------------------

  delete(id: ID): Result<void> {
    try {
      const stmt = this.db.prepare(`DELETE FROM ${this.tableName} WHERE id = ?`);
      const info = stmt.run(id);

      if (info.changes === 0) return failure('NOT_FOUND', `${this.tableName} record not found`);

      return success(undefined);
    } catch (err) {
      return failure('DATABASE', `Error deleting record from ${this.tableName}`, err);
    }
  }
}
import Database from 'better-sqlite3';
// import { db as db_Export} from '../../config/db.js';
import { I_Cart } from '../interfaces/cart.interfaces.js';
import { Logger } from '../../utils/logger.js';
import { BaseRepository } from './base.repository.js';
import { failure, Result, success } from '../../utils/Error/ErrorMangament.js';

const location = "core/repositories/cart.repository.ts"

const colmun_user_id = 'user_id';
const colmun_product_id = 'product_id';


type CartCreate = Omit<I_Cart, 'id' | 'created_at' | 'updated_at'>;
type CartUpdate = Partial<Pick<I_Cart, 'quantity' | 'price'>>;

export class CartRepository extends BaseRepository<I_Cart, CartCreate, CartUpdate> {

  constructor(db: Database.Database) {
    super(db, 'cart_items');
  }

  findByUserId(userId: number) : Result<I_Cart[]> {
      return this.findBy(colmun_user_id, userId);
  }

  findByProductId(userId: number) : Result<I_Cart[]> {
      return this.findBy(colmun_product_id, userId);
  }

  findOneByUserAndProduct(userId: number, productId: number) : Result<I_Cart[]> {
    try {
      const rows = this.db.prepare(`SELECT * FROM ${this.tableName} WHERE ${String(colmun_user_id)} = ? AND ${String(colmun_product_id)} = ?`).all(userId, productId);
      return success(rows as I_Cart[]);
    } catch (err) {
      return failure('DATABASE', `Error fetching ${this.tableName} by ${String(colmun_user_id)} AND ${String(colmun_product_id)}`, err);
    }
  }

}
import Database from 'better-sqlite3';
// import { db as db_Export} from '../../config/db.js';
import { I_Order } from '../interfaces/order.interfaces.js';
import { Logger } from '../../utils/logger.js';
import { BaseRepository } from './base.repository.js';
import { failure, Result, success } from '../../utils/Error/ErrorMangament.js';

const location = "core/repositories/order.repository.ts"

const colmun_user_id = 'user_id';
// const colmun_product_id = 'product_id';


type OrderCreate = Omit<I_Order, 'id' | 'created_at' | 'updated_at' | 'status' | 'stripe_payment_id'>;
type OrderUpdate = Partial<Pick<I_Order, 'status' | 'stripe_payment_id'>>;

export class OrderRepository extends BaseRepository<I_Order, OrderCreate, OrderUpdate> {

  constructor(db: Database.Database) {
    super(db, 'orders');
  }

  findByUserId(userId: number) : Result<I_Order[]> {
      return this.findBy(colmun_user_id, userId);
  }
}
import Database from 'better-sqlite3';
// import { db as db_Export} from '../../config/db.js';
import { I_OrderItems } from '../interfaces/order_items.interfaces.js';
import { Logger } from '../../utils/logger.js';
import { BaseRepository } from './base.repository.js';
import { failure, Result, success } from '../../utils/Error/ErrorMangament.js';

const location = "core/repositories/order.repository.ts"

const colmun_product_id = 'product_id';


type OrderItemssCreate = Omit<I_OrderItems, 'id' | 'created_at' | 'updated_at'>;
type OrderItemssUpdate = /*je ne veux rien update ce tableaux est figer car ce on ajoute des elment dans tableaux uniquement si Orders est crée et apres c'est sensé reste imuable*/;

export class OrderItemssRepository extends BaseRepository<I_OrderItems, OrderItemssCreate, OrderItemssUpdate> {

  constructor(db: Database.Database) {
    super(db, 'order_items');
  }

  findByProductId(userId: number) : Result<I_OrderItems[]> {
      return this.findBy(colmun_product_id, userId);
  }
}
import Database from 'better-sqlite3';
// import { db as db_Export} from '../../config/db.js';
import { I_Product } from '../interfaces/product.interfaces.js';
import { Logger } from '../../utils/logger.js';
import { BaseRepository } from './base.repository.js';
import { Result } from '../../utils/Error/ErrorMangament.js';

const location = "core/repositories/product.repository.ts"

type ProductCreate = Omit<I_Product, 'id' | 'created_at' | 'updated_at'>;
type ProductUpdate = Partial<Pick<I_Product, 'description' | 'price' | 'image' | 'stock'>>;

export class ProductRepository extends BaseRepository<I_Product, ProductCreate, ProductUpdate> {

  constructor(db: Database.Database) {
    super(db, 'products');
  }

  findOneByName(name: string): Result<I_Product[]> {
    return this.findBy('name', name);
  }
}
import Database from 'better-sqlite3';
// import { db as db_Export} from '../../config/db.js';
import { I_User } from '../interfaces/user.interfaces.js';
import { Logger } from '../../utils/logger.js';
import { BaseRepository } from './base.repository.js';
import { Result } from '../../utils/Error/ErrorMangament.js';

const location = "core/repositories/user.repository.ts"

type UserCreate = Omit<I_User, 'id' | 'created_at' | 'updated_at'>;
type UserUpdate = Partial<Pick<I_User, 'email' | 'password'>>;

export class UserRepository extends BaseRepository<I_User, UserCreate, UserUpdate> {
  constructor(db: Database.Database) {
    super(db, 'users');
  }

  // méthodes spécifiques si besoin
  findOneByEmail(email: string) : Result<I_User[]> {
    return this.findBy('email', email);
  }
}
